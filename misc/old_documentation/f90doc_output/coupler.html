<HTML>
<HEAD>
   <TITLE> module coupler (generated by f90doc) </TITLE>
</HEAD>
<H1> Module coupler </H1>
<PRE>module coupler

        ! Uses
    use <A HREF="iso_c_binding.html">ISO_C_BINDING</A>

        ! Interfaces
    public interface <A HREF="coupler.html#interface_cpl_send">CPL_send</A>
    public interface <A HREF="coupler.html#interface_cpl_recv">CPL_recv</A>

        ! Subroutines and functions
    public subroutine <A HREF="coupler.html#subroutine_cpl_gather">CPL_gather</A> (gatherarray, npercell, limits, recvarray)
    public subroutine <A HREF="coupler.html#subroutine_cpl_scatter">CPL_scatter</A> (scatterarray, npercell, limits, recvarray)
    private subroutine <A HREF="coupler.html#subroutine_cpl_send_3d">CPL_send_3d</A> (temp, icmin_send, icmax_send, jcmin_send, jcmax_send, kcmin_send, kcmax_send, send_flag)
    private subroutine <A HREF="coupler.html#subroutine_cpl_send_4d">CPL_send_4d</A> (asend, icmin_send, icmax_send, jcmin_send, jcmax_send, kcmin_send, kcmax_send, send_flag)
    private subroutine <A HREF="coupler.html#subroutine_cpl_send_xd">CPL_send_xd</A> (asend, icmin_send, icmax_send, jcmin_send, jcmax_send, kcmin_send, kcmax_send, send_flag)
    private subroutine <A HREF="coupler.html#subroutine_cpl_recv_3d">CPL_recv_3d</A> (temp, icmin_recv, icmax_recv, jcmin_recv, jcmax_recv, kcmin_recv, kcmax_recv, recv_flag)
    private subroutine <A HREF="coupler.html#subroutine_cpl_recv_4d">CPL_recv_4d</A> (arecv, icmin_recv, icmax_recv, jcmin_recv, jcmax_recv, kcmin_recv, kcmax_recv, recv_flag)
    private subroutine <A HREF="coupler.html#subroutine_cpl_recv_xd">CPL_recv_xd</A> (arecv, icmin_recv, icmax_recv, jcmin_recv, jcmax_recv, kcmin_recv, kcmax_recv, recv_flag)
    public subroutine <A HREF="coupler.html#subroutine_cpl_pack">CPL_pack</A> (unpacked, packed, realm, icmax_pack, icmin_pack, jcmax_pack, jcmin_pack, kcmax_pack, kcmin_pack)
    public subroutine <A HREF="coupler.html#subroutine_cpl_unpack">CPL_unpack</A> (packed, unpacked, realm)
    public subroutine <A HREF="coupler.html#subroutine_cpl_proc_extents">CPL_proc_extents</A> (coord, realm, extents, ncells)
    public subroutine <A HREF="coupler.html#subroutine_cpl_olap_extents">CPL_olap_extents</A> (coord, realm, extents, ncells)
    public subroutine <A HREF="coupler.html#subroutine_cpl_proc_portion">CPL_proc_portion</A> (coord, realm, limits, portion, ncells)
    public subroutine <A HREF="coupler.html#subroutine_cpl_cart_coords">CPL_Cart_coords</A> (COMM, rank, realm, maxdims, coords, ierr)
    public subroutine <A HREF="coupler.html#subroutine_cpl_get_rank">CPL_get_rank</A> (COMM, rank)
    public function <A HREF="coupler.html#function_cpl_overlap">CPL_overlap</A> () result (p)
    public subroutine <A HREF="coupler.html#subroutine_cpl_get">CPL_get</A> (icmax_olap, icmin_olap, jcmax_olap, jcmin_olap, kcmax_olap, kcmin_olap, density_cfd, density_md, dt_cfd, dt_MD, dx, dy, dz, ncx, ncy, ncz, xg, yg, zg, xL_md, xL_cfd, yL_md, yL_cfd, zL_md, zL_cfd, constraint_algo, constraint_CVflag, constraint_OT, constraint_NCER, constraint_Flekkoy, constraint_off, icmin_cnst, icmax_cnst, jcmin_cnst, jcmax_cnst, kcmin_cnst, kcmax_cnst, md_cfd_match_cellsize, staggered_averages, timestep_ratio)
    public function <A HREF="coupler.html#function_cpl_realm">CPL_realm</A> ()
    public function <A HREF="coupler.html#function_globalise">globalise</A> (r) result (rg)
    public function <A HREF="coupler.html#function_localise">localise</A> (r) result (rg)
    public function <A HREF="coupler.html#function_map_md2cfd_global">map_md2cfd_global</A> (r) result (rg)
    public function <A HREF="coupler.html#function_map_cfd2md_global">map_cfd2md_global</A> (r) result (rg)
    public function <A HREF="coupler.html#function_coupler_md_get_save_period">coupler_md_get_save_period</A> () result (p)
    public function <A HREF="coupler.html#function_coupler_md_get_average_period">coupler_md_get_average_period</A> () result (p)
    public function <A HREF="coupler.html#function_coupler_md_get_md_steps_per_cfd_dt">coupler_md_get_md_steps_per_cfd_dt</A> () result (p)
    public function <A HREF="coupler.html#function_coupler_md_get_nsteps">coupler_md_get_nsteps</A> () result (p)
    public function <A HREF="coupler.html#function_coupler_md_get_dt_cfd">coupler_md_get_dt_cfd</A> () result (p)

end module coupler
</PRE>
 Routines accessible from application ( molecular or continuum ) after 
 the name, in parenthesis, is the realm in which each routine must be called
<P>
 <UL>
 <LI>  CPL_send_data        	  (cfd+md)   sends grid data exchanged between 
                                      realms ( generic interface)
<P>
 <LI>  CPL_recv_data        	  (cfd+md)   receives data exchanged between realms 
                                      ( generic interface)
<P>
 <LI>  CPL_cfd_get               (cfd)    returns coupler internal parameters 
                                      for CFD realm
<P>
 <LI>  CPL_md_get                 (md)    returns coupler internal parameters 
                                      for MD realm
<P>
 <LI>  CPL_md_get_save_period     (md)    auxiliary used for testing
<P>
 <LI>  CPL_md_get_average_period  (md)    returns average period of BC
<P>
 <LI>  CPL_md_get_md_per_cfd_dt   (md) 	returns the number of step MD does for 
                                      each CFD step
<P>
 <LI>  CPL_md_get_nsteps          (md)    returm CFD nsteps  
<P>
 <LI>  CPL_md_get_dt_cfd          (md)    returns MD dt
<P>
 <LI>  CPL_md_set                 (md)    sets zL if CFD is 2D
<P>
 <LI>  CPL_md_get_density         (md)    gets CFD density
<P>
 <LI>  CPL_md_get_cfd_id          (md)    id for CFD code, possible values set 
                                      in coupler_parameters
<P>
 </UL>
<P>
<STRONG>Author:</STRONG> Lucian Anton, November 2011, Edward Smith, Dave Trevelyan September 2012
<P>
<STRONG>See also:</STRONG> module <A HREF="coupler_module.html">coupler_module</A>

<HR><H2> Description of Interfaces </H2>
<A NAME="interface_cpl_send"><H3>CPL_send</H3></A>
<PRE>public interface CPL_send
    module procedure <A HREF="#subroutine_cpl_send_3d">CPL_send_3d</A>
    module procedure <A HREF="#subroutine_cpl_send_4d">CPL_send_4d</A>
end interface CPL_send
</PRE>
<A NAME="interface_cpl_recv"><H3>CPL_recv</H3></A>
<PRE>public interface CPL_recv
    module procedure <A HREF="#subroutine_cpl_recv_3d">CPL_recv_3d</A>
    module procedure <A HREF="#subroutine_cpl_recv_4d">CPL_recv_4d</A>
end interface CPL_recv
</PRE>

<HR><H2> Description of Subroutines and Functions </H2>
<A NAME="subroutine_cpl_gather"><H3>CPL_gather</H3></A>
<PRE>public subroutine CPL_gather (gatherarray, npercell, limits, recvarray)
    real (kind=kind (0.d0)), dimension(:,:,:,:), intent(in) :: gatherarray
    integer, intent(in) :: npercell
    integer, intent(in), dimension (6) :: limits
    real (kind=kind (0.d0)), dimension(:,:,:,:), intent(inout) :: recvarray
    ! Calls: MPI_gatherv, deallocate_gather_u, pack_sendbuf, prepare_gatherv_parameters, unpack_recvbuf
end subroutine CPL_gather
</PRE>
 Perform gather operation on CPL_OLAP_COMM communicator. The CFD processor
 is the root process. The gathered data is effectively "slotted" into the
 correct part of the recvarray, and is intented for use in providing the
 CFD simulation boundary conditions with data obtained from the MD
 simulation.   
<P>
 <UL>
 <LI>  Synopsis
<P>
  <UL>
  <LI>  CPL_gather(gatherarray,npercell,limits,recvarray)
<P>
  </UL>
 <LI>  Input
<P>
  <UL>
  <LI>  gatherarray
   <UL>
   <LI>  Assumed shape array of data to be gathered from each MD processor
     in the overlap communicator.
<P>
   </UL>
  <LI>  limits
   <UL>
   <LI>  Integer array of length 6, specifying the global cell extents of the
     region to be gathered, is the same on ALL processors.
<P>
   </UL>
  <LI>  npercell
   <UL>
   <LI>  number of data points per cell to be gathered (integer)
     Note: should be the same as size(gatherarray(1)) for MD
     processor. E.G. npercell = 3 for gathering 3D velocities.
<P>
   </UL>
  </UL>
 <LI>  Input/Output
  <UL>
  <LI>  recvarray
   <UL>
   <LI>  The array in which the gathered values are to be stored on the CFD
     processor. The only values to be changed in recvarray are:
     recvarray(limits(1):limits(2),limits(3):limits(4),limits(5):limits(6))
<P>
   </UL>
  </UL>
 <LI>  Output Parameters
  <UL>
  <LI>  NONE
<P>
  </UL>
 </UL>
<P>
<STRONG>Author:</STRONG> David Trevelyan
<A NAME="subroutine_cpl_scatter"><H3>CPL_scatter</H3></A>
<PRE>public subroutine CPL_scatter (scatterarray, npercell, limits, recvarray)
    real (kind=kind (0.d0)), dimension(:,:,:,:), intent(in) :: scatterarray
    integer, intent(in) :: npercell
    integer, intent(in), dimension (6) :: limits
    real (kind=kind (0.d0)), dimension(:,:,:,:), intent(inout) :: recvarray
    ! Calls: MPI_scatterv, deallocate_scatter_s, pack_scatterbuf, prepare_scatterv_parameters, unpack_scatterbuf
end subroutine CPL_scatter
</PRE>
 Scatter cell-wise data from CFD processor to corresponding MD processors
 on the overlap communicator CPL_OLAP_COMM.
<P>
 <UL>
 <LI>  Synopsis
<P>
  <UL>
  <LI>  CPL_scatter(scatterarray,npercell,limits,recvarray)
<P>
  </UL>
 <LI>  Input
<P>
  <UL>
  <LI>  scatterarray
   <UL>
   <LI>  assumed shape array of data to be scattered (double precision)
<P>
   </UL>
  <LI>  limits
   <UL>
   <LI>  integer array of length 6, specifying the global cell extents of the
     region to be scattered, is the same on all processors.
<P>
   </UL>
  <LI>  npercell
   <UL>
   <LI>  number of data points per cell to be scattered (integer).
     Note: should be the same as size(scatterarray(1)) for CFD proc
<P>
   </UL>
  </UL>
 <LI>  Input/Output
  <UL>
  <LI>  recvarray
   <UL>
   <LI>  the array in which the scattered values are stored on the MD
     processors.
<P>
   </UL>
  </UL>
 <LI>  Output
  <UL>
  <LI>  NONE
<P>
  </UL>
 </UL>
<P>
<STRONG>Author:</STRONG> David Trevelyan
<A NAME="subroutine_cpl_send_3d"><H3>CPL_send_3d</H3></A>
<PRE>private subroutine CPL_send_3d (temp, icmin_send, icmax_send, jcmin_send, jcmax_send, kcmin_send, kcmax_send, send_flag)
    real (kind=kind (0.d0)), dimension(:,:,:), intent(in) :: temp
    integer, optional, intent(in) :: icmin_send
    integer, optional, intent(in) :: icmax_send
    integer, optional, intent(in) :: jcmin_send
    integer, optional, intent(in) :: jcmax_send
    integer, optional, intent(in) :: kcmin_send
    integer, optional, intent(in) :: kcmax_send
    logical, optional, intent(out) :: send_flag
    ! Calls: CPL_send_xd, error_abort
end subroutine CPL_send_3d
</PRE>
 CPL_send_data wrapper for 3d arrays
 see CPL_send_xd for input description
<P>
<STRONG>See also:</STRONG> <A HREF="coupler.html#subroutine_cpl_send_xd">subroutine_CPL_send_xd</A> in module <A HREF="coupler.html">coupler</A>
<A NAME="subroutine_cpl_send_4d"><H3>CPL_send_4d</H3></A>
<PRE>private subroutine CPL_send_4d (asend, icmin_send, icmax_send, jcmin_send, jcmax_send, kcmin_send, kcmax_send, send_flag)
    real (kind=kind (0.d0)), dimension(:,:,:,:), intent(in) :: asend
    integer, optional, intent(in) :: icmin_send
    integer, optional, intent(in) :: icmax_send
    integer, optional, intent(in) :: jcmin_send
    integer, optional, intent(in) :: jcmax_send
    integer, optional, intent(in) :: kcmin_send
    integer, optional, intent(in) :: kcmax_send
    logical, optional, intent(out) :: send_flag
    ! Calls: CPL_send_xd, error_abort
end subroutine CPL_send_4d
</PRE>
 CPL_send_data wrapper for 4d arrays
 see CPL_send_xd for input description
<P>
<STRONG>See also:</STRONG> <A HREF="coupler.html#subroutine_cpl_send_xd">subroutine_CPL_send_xd</A> in module <A HREF="coupler.html">coupler</A>
<A NAME="subroutine_cpl_send_xd"><H3>CPL_send_xd</H3></A>
<PRE>private subroutine CPL_send_xd (asend, icmin_send, icmax_send, jcmin_send, jcmax_send, kcmin_send, kcmax_send, send_flag)
    real (kind=kind (0.d0)), dimension(:,:,:,:), intent(in) :: asend
    integer, intent(in) :: icmin_send
    integer, intent(in) :: icmax_send
    integer, intent(in) :: jcmin_send
    integer, intent(in) :: jcmax_send
    integer, intent(in) :: kcmin_send
    integer, intent(in) :: kcmax_send
    logical, optional, intent(out) :: send_flag
    ! Calls: CPL_Cart_coords, CPL_proc_extents, CPL_proc_portion, MPI_Graph_neighbors, MPI_Graph_neighbors_count, MPI_send
end subroutine CPL_send_xd
</PRE>
 Send data from the local grid to the associated ranks from the other 
 realm
<P>
 <UL>
 <LI>  Synopsis
<P>
  <UL>
  <LI>  CPL_send_xd(asend,icmin_send,icmax_send,jcmin_send,  
  </UL>
 </UL>
						     jcmax_send,kcmin_send,kcmax_send,send_flag)
<P>
 <UL>
 <LI>  Input Parameters
<P>
   <UL>
   <LI>  asend
<P>
   <LI>  jcmax_recv
<P>
   <LI>  jcmin_recv
<P>
   </UL>
 <LI>  Output Parameter
<P>
   <UL>
   <LI>  send_flag
<P>
   </UL>
 </UL>
<P>
<STRONG>Author:</STRONG> Edward Smith
<A NAME="subroutine_cpl_recv_3d"><H3>CPL_recv_3d</H3></A>
<PRE>private subroutine CPL_recv_3d (temp, icmin_recv, icmax_recv, jcmin_recv, jcmax_recv, kcmin_recv, kcmax_recv, recv_flag)
    real (kind=kind (0.d0)), dimension(:,:,:), intent(inout) :: temp
    integer, optional, intent(in) :: icmin_recv
    integer, optional, intent(in) :: icmax_recv
    integer, optional, intent(in) :: jcmin_recv
    integer, optional, intent(in) :: jcmax_recv
    integer, optional, intent(in) :: kcmin_recv
    integer, optional, intent(in) :: kcmax_recv
    logical, optional, intent(out) :: recv_flag
    ! Calls: CPL_recv_xd, error_abort
end subroutine CPL_recv_3d
</PRE>
 CPL_recv_xd wrapper for 3d arrays
 see CPL_recv_xd for input description
<P>
<STRONG>See also:</STRONG> <A HREF="coupler.html#subroutine_cpl_recv_xd">subroutine_CPL_recv_xd</A> in module <A HREF="coupler.html">coupler</A>
<A NAME="subroutine_cpl_recv_4d"><H3>CPL_recv_4d</H3></A>
<PRE>private subroutine CPL_recv_4d (arecv, icmin_recv, icmax_recv, jcmin_recv, jcmax_recv, kcmin_recv, kcmax_recv, recv_flag)
    real (kind=kind (0.d0)), dimension(:,:,:,:), intent(out) :: arecv
    integer, optional, intent(in) :: icmin_recv
    integer, optional, intent(in) :: icmax_recv
    integer, optional, intent(in) :: jcmin_recv
    integer, optional, intent(in) :: jcmax_recv
    integer, optional, intent(in) :: kcmin_recv
    integer, optional, intent(in) :: kcmax_recv
    logical, optional, intent(out) :: recv_flag
    ! Calls: CPL_recv_xd, error_abort
end subroutine CPL_recv_4d
</PRE>
 CPL_recv_xd  wrapper for 4d arrays
 See CPL_recv_xd for input description
<P>
<STRONG>See also:</STRONG> <A HREF="coupler.html#subroutine_cpl_recv_xd">subroutine_CPL_recv_xd</A> in module <A HREF="coupler.html">coupler</A>
<A NAME="subroutine_cpl_recv_xd"><H3>CPL_recv_xd</H3></A>
<PRE>private subroutine CPL_recv_xd (arecv, icmin_recv, icmax_recv, jcmin_recv, jcmax_recv, kcmin_recv, kcmax_recv, recv_flag)
    real (kind=kind (0.d0)), dimension(:,:,:,:), intent(inout) :: arecv
    integer, intent(in) :: icmin_recv
    integer, intent(in) :: icmax_recv
    integer, intent(in) :: jcmin_recv
    integer, intent(in) :: jcmax_recv
    integer, intent(in) :: kcmin_recv
    integer, intent(in) :: kcmax_recv
    logical, optional, intent(out) :: recv_flag
    ! Calls: CPL_Cart_coords, CPL_proc_extents, CPL_proc_portion, MPI_Graph_neighbors, MPI_Graph_neighbors_count, MPI_irecv, MPI_waitall
end subroutine CPL_recv_xd
</PRE>
 Receive data from to local grid from the associated ranks from the other 
 realm
<P>
 <UL>
 <LI>  Synopsis
<P>
  <UL>
  <LI>  CPL_recv_xdarecv,icmin_recv,icmax_recv,jcmin_recv,  
  </UL>
 </UL>
						     jcmax_recv,kcmin_recv,kcmax_recv,recv_flag)
<P>
 <UL>
 <LI>  Input Parameters
<P>
   <UL>
   <LI>  arecv
<P>
   <LI>  jcmax_recv
<P>
   <LI>  jcmin_recv
<P>
   <LI>  index_transpose
<P>
   </UL>
 <LI>  Output Parameter
<P>
   <UL>
   <LI>  recv_flag
<P>
   </UL>
 </UL>
<P>
<STRONG>Author:</STRONG> Edward Smith
<A NAME="subroutine_cpl_pack"><H3>CPL_pack</H3></A>
<PRE>public subroutine CPL_pack (unpacked, packed, realm, icmax_pack, icmin_pack, jcmax_pack, jcmin_pack, kcmax_pack, kcmin_pack)
    real (kind=kind (0.d0)), dimension(:,:,:,:), intent(in) :: unpacked
    real (kind=kind (0.d0)), dimension(:), allocatable, intent(out) :: packed
    integer, intent(in) :: realm
    integer, optional, intent(in) :: icmax_pack
    integer, optional, intent(in) :: icmin_pack
    integer, optional, intent(in) :: jcmax_pack
    integer, optional, intent(in) :: jcmin_pack
    integer, optional, intent(in) :: kcmax_pack
    integer, optional, intent(in) :: kcmin_pack
    ! Calls: CPL_Cart_coords, CPL_olap_extents, MPI_Graph_neighbors, MPI_Graph_neighbors_count, error_abort
end subroutine CPL_pack
</PRE>
<A NAME="subroutine_cpl_unpack"><H3>CPL_unpack</H3></A>
<PRE>public subroutine CPL_unpack (packed, unpacked, realm)
    real (kind=kind (0.d0)), dimension(:), allocatable, intent(inout) :: packed
    real (kind=kind (0.d0)), dimension(:,:,:,:), allocatable, intent(out) :: unpacked
    integer, intent(in) :: realm
    ! Calls: CPL_Cart_coords, CPL_proc_extents, MPI_Graph_neighbors, MPI_Graph_neighbors_count
end subroutine CPL_unpack
</PRE>
<A NAME="subroutine_cpl_proc_extents"><H3>CPL_proc_extents</H3></A>
<PRE>public subroutine CPL_proc_extents (coord, realm, extents, ncells)
    integer, intent(in), dimension (3) :: coord
    integer, intent(in) :: realm
    integer, intent(out), dimension (6) :: extents
    integer, optional, intent(out) :: ncells
    ! Calls: error_abort
end subroutine CPL_proc_extents
</PRE>
 Gets maximum and minimum cells for processor coordinates
<P>
 <UL>
 <LI>  Synopsis
<P>
  <UL>
  <LI>  CPL_proc_extents(coord,realm,extents,ncells)
<P>
  </UL>
 <LI>  Input
<P>
  <UL>
  <LI>  coord
   <UL>
   <LI>  processor cartesian coordinate (3 x integer) 
<P>
   </UL>
  <LI>  realm
   <UL>
   <LI>  cfd_realm (1) or md_realm (2) (integer) 
<P>
   </UL>
  </UL>
 <LI>  Input/Output
  <UL>
  <LI>  NONE
<P>
  </UL>
 <LI>  Output
<P>
  <UL>
  <LI>  extents
   <UL>
   <LI>  Six components array which defines processor extents
     xmin,xmax,ymin,ymax,zmin,zmax (6 x integer) 
<P>
   </UL>
  <LI>  ncells (optional)
   <UL>
   <LI>  number of cells on processor (integer) 
<P>
   </UL>
  </UL>
 </UL>
<P>
<STRONG>Author:</STRONG> David Trevelyan
<A NAME="subroutine_cpl_olap_extents"><H3>CPL_olap_extents</H3></A>
<PRE>public subroutine CPL_olap_extents (coord, realm, extents, ncells)
    integer, intent(in), dimension (3) :: coord
    integer, intent(in) :: realm
    integer, intent(out), dimension (6) :: extents
    integer, optional, intent(out) :: ncells
    ! Calls: error_abort
end subroutine CPL_olap_extents
</PRE>
 Get maximum and minimum cells for current communicator within
 the overlapping region only
<P>
 <UL>
 <LI>  Synopsis 
<P>
  <UL>
  <LI>  CPL_olap_extents(coord,realm,extents,ncells)
<P>
  </UL>
 <LI>  Input 
<P>
  <UL>
  <LI>  coord
   <UL>
   <LI>  processor cartesian coordinate (3 x integer) 
<P>
   </UL>
  <LI>  realm
   <UL>
   <LI>  cfd_realm (1) or md_realm (2) (integer) 
<P>
   </UL>
  </UL>
 <LI>  Input/Output
  <UL>
  <LI>  NONE
<P>
  </UL>
 <LI>  Output 
<P>
  <UL>
  <LI>  extents
   <UL>
   <LI>  Six components array which defines processor extents within
     the overlap region only: xmin,xmax,ymin,ymax,zmin,zmax (6 x integer) 
<P>
   </UL>
  <LI>  ncells (optional)
   <UL>
   <LI>  number of cells on processor (integer) 
<P>
   </UL>
  </UL>
 </UL>
<P>
<STRONG>Author:</STRONG> David Trevelyan
<A NAME="subroutine_cpl_proc_portion"><H3>CPL_proc_portion</H3></A>
<PRE>public subroutine CPL_proc_portion (coord, realm, limits, portion, ncells)
    integer, intent(in), dimension (3) :: coord
    integer, intent(in) :: realm
    integer, intent(in), dimension (6) :: limits
    integer, intent(out), dimension (6) :: portion
    integer, optional, intent(out) :: ncells
    ! Calls: CPL_proc_extents
end subroutine CPL_proc_portion
</PRE>
 Get maximum and minimum cell indices, i.e. the 'portion', of the
 input cell extents 'limits' that is contributed by the current
 overlapping processor. 
<P>
 <UL>
 <LI>  Synopsis
  <UL>
  <LI>  CPL_proc_portion(coord,realm,limits,portion,ncells)
<P>
  </UL>
 <LI>  Input
<P>
  <UL>
  <LI>  coord
   <UL>
   <LI>  processor cartesian coordinate (3 x integer) 
<P>
   </UL>
  <LI>  realm
   <UL>
   <LI>  cfd_realm (1) or md_realm (2) (integer) 
<P>
   </UL>
  <LI>  limits(6)
   <UL>
   <LI>  Array of cell extents that specify the input region. 
<P>
   </UL>
  </UL>
 <LI>  Input/Output
  <UL>
  <LI>  NONE
<P>
  </UL>
 <LI>  Output
<P>
  <UL>
  <LI>  portion(6) 
   <UL>
   <LI>  Array of cell extents that define the local processor's
     contribution to the input region 'limits'.
<P>
   <LI>  ncells (optional)
    <UL>
    <LI>  number of cells in portion (integer) 
<P>
    </UL>
   </UL>
  </UL>
 <LI>  Note: limits(6) and portion(6) are of the form:
   (xmin,xmax,ymin,ymax,zmin,zmax)
 </UL>
<P>
<STRONG>Author:</STRONG> David Trevelyan
<A NAME="subroutine_cpl_cart_coords"><H3>CPL_Cart_coords</H3></A>
<PRE>public subroutine CPL_Cart_coords (COMM, rank, realm, maxdims, coords, ierr)
    integer, intent(in) :: COMM
    integer, intent(in) :: rank
    integer, intent(in) :: realm
    integer, intent(in) :: maxdims
    integer, intent(out), dimension (maxdims) :: coords
    integer, intent(out) :: ierr
    ! Calls: error_abort
end subroutine CPL_Cart_coords
</PRE>
 Determines process coords in appropriate realm's cartesian topology 
 given a rank in any communicator
<P>
 <UL>
 <LI>  Synopsis
<P>
  <UL>
  <LI>  CPL_Cart_coords(COMM, rank, realm, maxdims, coords, ierr)
<P>
  </UL>
 <LI>  Input Parameters
<P>
  <UL>
  <LI>  comm
   <UL>
   <LI>  communicator with cartesian structure (handle) 
<P>
   </UL>
  <LI>  realm
   <UL>
   <LI>  cfd_realm (1) or md_realm (2) (integer) 
<P>
   </UL>
  <LI>  rank
   <UL>
   <LI>  rank of a process within group of comm (integer) 
      NOTE fortran convention rank=1 to nproc
<P>
   </UL>
  <LI>  maxdims
   <UL>
   <LI>  length of vector coords in the calling program (integer) 
<P>
   </UL>
  </UL>
 <LI>  Output Parameter
<P>
  <UL>
  <LI>  coords
   <UL>
   <LI>  integer array (of size ndims) containing the Cartesian coordinates 
     of specified process (integer) 
<P>
   </UL>
  <LI>  ierr
   <UL>
   <LI>  error flag
   </UL>
  </UL>
 </UL>
<P>
<STRONG>Author:</STRONG> Edward Smith
<A NAME="subroutine_cpl_get_rank"><H3>CPL_get_rank</H3></A>
<PRE>public subroutine CPL_get_rank (COMM, rank)
    integer, intent(in) :: COMM
    integer, intent(out) :: rank
    ! Calls: error_abort
end subroutine CPL_get_rank
</PRE>
 Return rank of current processor in specified COMM 
<P>
 <UL>
 <LI>  Synopsis
<P>
  <UL>
  <LI>  CPL_get_rank(COMM, rank)
<P>
  </UL>
 <LI>  Input Parameters
<P>
  <UL>
  <LI>  comm
   <UL>
   <LI>  communicator with cartesian structure (handle) 
<P>
   </UL>
  </UL>
 <LI>  Output Parameter
<P>
  <UL>
  <LI>  rank
   <UL>
   <LI>  rank of a process within group of comm (integer) 
      NOTE fortran convention rank=1 to nproc
<P>
   </UL>
  </UL>
 </UL>
<P>
<STRONG>Author:</STRONG> Edward Smith
<A NAME="function_cpl_overlap"><H3>CPL_overlap</H3></A>
<PRE>public function CPL_overlap () result (p)
    logical :: p
end function CPL_overlap
</PRE>
 Check if current processor is in the overlap region
<P>
 <UL>
 <LI>  Synopsis
<P>
  <UL>
  <LI>  CPL_olap_check()
<P>
  </UL>
 <LI>  Input Parameters
<P>
  <UL>
  <LI>  NONE
<P>
  </UL>
 <LI>  Returns
<P>
  <UL>
  <LI>  CPL_olap_check
  </UL>
 </UL>
	 - True if calling processor is in the overlap region
     and false otherwise
<P>
<STRONG>Author:</STRONG> Edward Smith
<A NAME="subroutine_cpl_get"><H3>CPL_get</H3></A>
<PRE>public subroutine CPL_get (icmax_olap, icmin_olap, jcmax_olap, jcmin_olap, kcmax_olap, kcmin_olap, density_cfd, density_md, dt_cfd, dt_MD, dx, dy, dz, ncx, ncy, ncz, xg, yg, zg, xL_md, xL_cfd, yL_md, yL_cfd, zL_md, zL_cfd, constraint_algo, constraint_CVflag, constraint_OT, constraint_NCER, constraint_Flekkoy, constraint_off, icmin_cnst, icmax_cnst, jcmin_cnst, jcmax_cnst, kcmin_cnst, kcmax_cnst, md_cfd_match_cellsize, staggered_averages, timestep_ratio)
    integer, optional, intent(out) :: icmax_olap
    integer, optional, intent(out) :: icmin_olap
    integer, optional, intent(out) :: jcmax_olap
    integer, optional, intent(out) :: jcmin_olap
    integer, optional, intent(out) :: kcmax_olap
    integer, optional, intent(out) :: kcmin_olap
    real (kind=kind (0.d0)), optional, intent(out) :: density_cfd
    real (kind=kind (0.d0)), optional, intent(out) :: density_md
    real (kind=kind (0.d0)), optional, intent(out) :: dt_cfd
    real (kind=kind (0.d0)), optional, intent(out) :: dt_MD
    real (kind=kind (0.d0)), optional, intent(out) :: dx
    real (kind=kind (0.d0)), optional, intent(out) :: dy
    real (kind=kind (0.d0)), optional, intent(out) :: dz
    integer, optional, intent(out) :: ncx
    integer, optional, intent(out) :: ncy
    integer, optional, intent(out) :: ncz
    real (kind=kind (0.d0)), optional, dimension(:,:), allocatable, intent(out) :: xg
    real (kind=kind (0.d0)), optional, dimension(:,:), allocatable, intent(out) :: yg
    real (kind=kind (0.d0)), optional, dimension(:), allocatable, intent(out) :: zg
    real (kind=kind (0.d0)), optional, intent(out) :: xL_md
    real (kind=kind (0.d0)), optional, intent(out) :: xL_cfd
    real (kind=kind (0.d0)), optional, intent(out) :: yL_md
    real (kind=kind (0.d0)), optional, intent(out) :: yL_cfd
    real (kind=kind (0.d0)), optional, intent(out) :: zL_md
    real (kind=kind (0.d0)), optional, intent(out) :: zL_cfd
    integer, optional, intent(out) :: constraint_algo
    integer, optional, intent(out) :: constraint_CVflag
    integer, optional, intent(out) :: constraint_OT
    integer, optional, intent(out) :: constraint_NCER
    integer, optional, intent(out) :: constraint_Flekkoy
    integer, optional, intent(out) :: constraint_off
    integer, optional, intent(out) :: icmin_cnst
    integer, optional, intent(out) :: icmax_cnst
    integer, optional, intent(out) :: jcmin_cnst
    integer, optional, intent(out) :: jcmax_cnst
    integer, optional, intent(out) :: kcmin_cnst
    integer, optional, intent(out) :: kcmax_cnst
    integer, optional, intent(out) :: md_cfd_match_cellsize
    logical, optional, dimension(3), intent(out) :: staggered_averages
    integer, optional, intent(out) :: timestep_ratio
end subroutine CPL_get
</PRE>
 Wrapper to retrieve (read only) parameters from the coupler_module 
 Note - this ensures all variable in the coupler are protected
 from corruption by either CFD or MD codes
<P>
 <UL>
 <LI>  Synopsis
<P>
  <UL>
  <LI>  CPL_get([see coupler_module])
<P>
  </UL>
 <LI>  Input Parameters
<P>
  <UL>
  <LI>  NONE
<P>
  </UL>
 <LI>  Output Parameter
<P>
  <UL>
  <LI>  @see coupler_module
<P>
  </UL>
 </UL>
<P>
<STRONG>Author:</STRONG> Edward Smith
<A NAME="function_cpl_realm"><H3>CPL_realm</H3></A>
<PRE>public function CPL_realm ()
    integer :: CPL_realm
end function CPL_realm
</PRE>
<A NAME="function_globalise"><H3>globalise</H3></A>
<PRE>public function globalise (r) result (rg)
    real (kind=kind (0.d0)), intent(in), dimension (3) :: r
    real (kind=kind (0.d0)), dimension (3) :: rg
end function globalise
</PRE>
<A NAME="function_localise"><H3>localise</H3></A>
<PRE>public function localise (r) result (rg)
    real (kind=kind (0.d0)), intent(in), dimension (3) :: r
    real (kind=kind (0.d0)), dimension (3) :: rg
end function localise
</PRE>
<A NAME="function_map_md2cfd_global"><H3>map_md2cfd_global</H3></A>
<PRE>public function map_md2cfd_global (r) result (rg)
    real (kind=kind (0.d0)), intent(in), dimension (3) :: r
    real (kind=kind (0.d0)), dimension (3) :: rg
end function map_md2cfd_global
</PRE>
<A NAME="function_map_cfd2md_global"><H3>map_cfd2md_global</H3></A>
<PRE>public function map_cfd2md_global (r) result (rg)
    real (kind=kind (0.d0)), intent(in), dimension (3) :: r
    real (kind=kind (0.d0)), dimension (3) :: rg
end function map_cfd2md_global
</PRE>
<A NAME="function_coupler_md_get_save_period"><H3>coupler_md_get_save_period</H3></A>
<PRE>public function coupler_md_get_save_period () result (p)
    integer :: p
end function coupler_md_get_save_period
</PRE>
<A NAME="function_coupler_md_get_average_period"><H3>coupler_md_get_average_period</H3></A>
<PRE>public function coupler_md_get_average_period () result (p)
    integer :: p
end function coupler_md_get_average_period
</PRE>
<A NAME="function_coupler_md_get_md_steps_per_cfd_dt"><H3>coupler_md_get_md_steps_per_cfd_dt</H3></A>
<PRE>public function coupler_md_get_md_steps_per_cfd_dt () result (p)
    integer :: p
end function coupler_md_get_md_steps_per_cfd_dt
</PRE>
<A NAME="function_coupler_md_get_nsteps"><H3>coupler_md_get_nsteps</H3></A>
<PRE>public function coupler_md_get_nsteps () result (p)
    integer :: p
end function coupler_md_get_nsteps
</PRE>
<A NAME="function_coupler_md_get_dt_cfd"><H3>coupler_md_get_dt_cfd</H3></A>
<PRE>public function coupler_md_get_dt_cfd () result (p)
    real (kind=kind (0.d0)) :: p
end function coupler_md_get_dt_cfd
</PRE>
</HTML>
