
This case tests user-explicit treatment of the nonlinear terms.

Specifically, it allows the user to set a rhs term of the form:

(1)    rhs = - [ (U.grad V) + (V.grad U) ]

where U and V can be vector fields of the user's choice.

Here, we test the functionality of this feature by considering the 
Kovazsnay problem with the standard Nek5000 nonlinear treatment 
turned OFF, which is accomplished by setting IFNAV to F in the .rea 
file.   The net result is an unsteady Stokes problem.

We then augment the Stokes problem with a time-dependent forcing
by setting ffx and ffy in userf() in the .usr file.  The pointwise
values of ffx and ffy are taken from an array that is computed 
once per timestep in userchk.   These nonlinear contributions
are generated by the following ad hoc test routine:

      call set_ns_rhs   !  Test ad-hoc nonlinear function evaluation

which in turn makes the call to effect (1):

      call ugv_vgu(w1,w2,w3,vx,vy,vz,vx,vy,vz,1)

This case gives a final error of 1.e-8, a strong indicator that things
are indeed functioning correctly.   Turning the functionality off via
"call opzero(w1,w2,w3)" leads to and order unity error.


   Note that the timing of the call to userhk is precisely correct
in the following sense.  Userchk is called at the _end_ of the nth 
timestep, when the time is set to  time=n*dt (for dt constant, say).

At this point, all arrays contain values associated with time t=n*dt.
(On the first userchk call, just after setting initial conditions,
we have time t=0.)

Thus, in the example described above the arrays w1() and w2() are
filled with quantites from time-level n.

On the _next_ step, level n+1, the ffx and ffy arrays are filled by
userf, which is expecting function values from time level n.   In fact,
when userf() is called, the "time" variable is automatically set back
to its value at Step n, in case the user is providing a function with
an explicit dependence on time.   All values generated in userf() are
then stored for the given time level, so that multiple preceding levels
can be used to generate the proper kth-order extrapolation in time.


